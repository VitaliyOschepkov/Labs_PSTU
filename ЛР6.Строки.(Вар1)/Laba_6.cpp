#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    const int startSize = 256; //ограничиваем размер массива
    char str[startSize];
    cout << "Введите строку - " ;
    cin.getline(str, '.'); //считываем строку до точки
    char str_1[startSize]; //создаем дополнительный массив, который будет хранить все символы слитно (и без точки на конце)
    int j = 0; //счетчик для цикла str_1
    for (int i = 0; i < startSize; i++) //цикл "бежит" по считанному массиву (str) и переписывает символы в новый массив (str_1), при этом пробелы пропускает, а если доберется до точки, то записывает терминальный ноль и выходит из цикла
    {
        if (str[i] == ' ')
            continue;
        if (str[i] == '.')
        {
            str_1[j] = '\0';
            break;
        }
        str_1[j] = str[i];
        j++;
    }
    const int resSize = strlen(str_1); //размер второго вспомогательного массива str_2
    char * str_2 = new char[resSize + 1]; //динамически создаем второй массив, так как нельзя создать массив (в GCC++ можно) через константу-переменную (константа заданная через переменную)
    for (int i = 0; i < resSize; i++) //переписывает массив str_1 только наоборот в массив str_2
    {
        str_2[i] = str_1[resSize - 1 - i]; //т.е. последний элемент str_1 становится первым, второй с конца - вторым и т.д.
    }
    str_2[resSize] = '\0'; //в последний элемент кладем терминальный ноль
    if (!strcmp(str_1, str_2))
        cout << "Строка палиндром"; //функция strcmp() сравнивает два массива, если они равны, то возвращает 0, иначе число, отличное от 0 (не буду тут подробнее)
    else
        cout << "Строка не палиндром";
    delete[] str_2; //очищаем динамически выделенную память (забыл это написать сразу)
    return 0;
}
